{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本篇Gitbook主要记录本人在项目中遇到的问题，以及学习中的总结。 本人岗位为前端开发，主要技术栈： VueJs Webpack NodeJS Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:30:54 "},"webpack/":{"url":"webpack/","title":"Webpack教程","keywords":"","body":"Webpack教程 背景 Webpack从零开始，由浅入深，结合实例，逐步上手掌握。阅读建议：从第一篇开始，按顺序阅读。 教程环境 node12.20.2webpack5.23.0webpack-cli4.5.0 官网文档 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:33:02 "},"webpack/1_HelloWebpack.html":{"url":"webpack/1_HelloWebpack.html","title":"Hello Webpack","keywords":"","body":"Hello Webpack 文件列表： 总共4个文件： index.html 1.3.3 使用Webpack main.js const show = require('./show.js') show('Webpack') show.js function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 14:36:25 "},"webpack/2_CssLoader.html":{"url":"webpack/2_CssLoader.html","title":"Css Loader","keywords":"","body":"Css Loader 基于上个例子，我们加一点css样式。 修改文件 增加style.css #app { font-size: 25px; font-weight: bolder; color: blue; } 修改main.js require('./style.css') const show = require('./show.js') show('Webpack') 增加第1行，引入css文件。注意这里是通过js代码引入的，而不是html文件中通过link引入。 修改webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] } } 其中9-16行，为新加配置。主要作用是为css文件指定了Loader，因为webpack只能解析js文件，所以我们要使用style-loader和css-loader对css文件解析。同时别忘了安装这2个插件，安装命令： npm init npm install -D style-loader css-loader Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： 打开bundle.js文件，我们可以发现，css代码是在js文件中，并没有生成新的css文件。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 14:45:57 "},"webpack/3_Plugin.html":{"url":"webpack/3_Plugin.html","title":"Plugin","keywords":"","body":"Plugin 基于上个例子，我们把css样式从js代码中剥离出来。最终效果是，打包出来后为2个文件，js和css代码分开，通过mini-css-extract-plugin插件实现。 修改文件 修改index.html 1.3.5 使用Plugin 新增第7行代码，至于main后面的hash如何确定？最后会介绍。 修改webpack.config.js const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }) ] } 引入mini-css-extract-plugin插件，将css代码剥离出来。 别忘了安装依赖 npm install -D mini-css-extract-plugin Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.141bbd3b8e8be1b45fb5.css，打开index.html后，效果和上一个例子一致，说明css样式生效。 FAQ css文件名的问题 第一步中index.html中css文件名的问题，我们尝试以下2种修改： 将css文件名设为定值 webpack.config.js中filename直接改为style.css。 打包后，发现css文件名生效，此时记得修改index.html中css文件名，此种方法也可生效，但不推荐。 不修改文件名，修改css内容 我们修改style.css中的内容，任意修改，增加，删除内容。 重新打包后，发现文件名后缀hash变化了。 因为我们定义的文件名是基于文件内容的，所以一旦css文件发生变化，文件名也会变化。所以本篇一开始定义的带hash的filename并不好。因为事先我们并不知道文件名中的hash，并且文件内容一旦发生变化文件名也会变化。 filename: `[name].[contenthash].css` 那我们把后缀hash去除，试试看。 filename: `[name].css` 结果是打包生成了main.css。同时修改index.html的引用，可生效，但不推荐。 为什么要给文件名加上hash？ 为了解决引用缓存的问题。所以上面的2种解决办法不推荐，会有缓存问题。 如何解决hash文件名引入的问题？ 使用html-webpack-plugin插件，见下篇。 参考文档 npm extract-text-webpack-plugin webpack的extract-text-webpack-plugin插件 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:41:50 "},"webpack/4_html-webpack-plugin.html":{"url":"webpack/4_html-webpack-plugin.html","title":"html-webpack-plugin","keywords":"","body":"html-webpack-plugin 该插件的基本作用就是生成html文件。原理很简单： 将 webpack中entry配置的相关入口chunk 和 extract-text-webpack-plugin抽取的css样式 插入到该插件提供的template或者templateContent配置项指定的内容基础上生成一个html文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。 修改文件 修改index.html文件，去除掉对js和css文件的引用，让插件自动完成： 1.3.5 使用Plugin - html-webpack-plugin 最重要的是修改webpack.config.js，引入html-webpack-plugin插件。 const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'index.html') }) ] } 不要在意插件的位置，因为插件执行的顺序并不取决于数组中的位置，而是取决于侦听的钩子。 Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.9e4519333259a0e9bd53.css和index.html，打开index.html后，效果和上一个例子一致，说明css样式生效。 与之前不同的是，此时会生成一个新的index.html文件。该文件是基于template指定的文件，将js和css文件以script和link引入生成的新文件，这就是html-webpack-plugin插件的作用！ 参考文档 npm html-webpack-plugin html-webpack-plugin详解 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:39:28 "},"webpack/5_devServer.html":{"url":"webpack/5_devServer.html","title":"devServer","keywords":"","body":"devServer devServer是Webpack的功能之一，可以实现： 发布文件 热更新 修改文件 修改webpack.config.js，增加一行devServer的配置： module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), devServer: { open: true }, // ... } 安装webpack-dev-server插件 npm install -g webpack-dev-server Webpack build 运行命令有变化： webpack-dev-server --hot --devtool source-map 运行成功后，会自动打开页面，如下效果： 和之前有以下变化： 最直观的，页面会自动打开。 地址栏中不再是本地文件路径，而是localhost:8080。 修改show.js文件，先自动打包，然后页面会自动刷新生效。 FAQ 修改style.css文件为什么页面不会自动刷新？ 见Webpack官方文档中的解释《MiniCssExtractPlugin》 所以，如果想让css修改实时刷新，修改webpack.config.js，重新打包后生效！ const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [ isDevMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader' ], } ] }, // ... } 二者有什么不同呢？ 开发环境使用style-loader，直接将css注入到head标签内，如下图： 生成环境使用mini-css-extract-plugin，将css代码剥离。 有没有其他办法解决？ 除了上面官方的方法外，还有一种办法是改变filename。 修改webpack.config.js文件： const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ], plugins: [ new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }), // ... ] } } 思路是，开发环境下固定住css文件的文件名。这样css文件修改后，能实现自动更新。而且不会有缓存问题，因为webpack-dev-server会自动在后追加时间戳的hash： 由此推断第一个问题的原因是css文件名hash变化，html中引用css的文件名没有及时更新。我们将filename改为cotenthash，修改css中的颜色，之后如下图： 我们发现： webpack确实侦听到变化，并且重新打包了。css文件名由main.9e4519333259a0e9bd53.css变为main.c9189b62182a414e712f.css。 页面DOM也发生变化了，首先css文件名后多了时间戳，说明更新了css文件。另外多了一个js文件main.cc05876de95eea54c5bb.hot-update.js的引用，这个文件的作用正是刷新页面。 但是为什么页面中样式没有更新？ 我们看这个main.cc05876de95eea54c5bb.hot-update.js文件内容，并未包含最新的css文件名，所以页面无法更新css样式。而问题2的解决办法正是去除hash的影响。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 09:15:30 "},"webpack/6_multipleEntry.html":{"url":"webpack/6_multipleEntry.html","title":"Multiple Entry","keywords":"","body":"Multiple Entry Webpack支持多入口文件的打包。多入口意味着入口文件也是多个。 修改文件 准备以下5个文件 index.html show.js function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show main.js const show = require('./show.js') show('index') login.js const show = require('./show.js') show('login') webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }) ] } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成4个新文件：index.html、login.html、index.js、login.js。分别打开2个html文件，发现内容生效。 总结 总结以下几点 title的设置 webpack.config.js中设置title，在index.html中读取title。 chunks的作用 把webpack.config.js中2的chunks的配置删除，打包后会发生什么？ 结果打包生成的index.html和login.html中均引用了index.js和login.js。 修改chunks，如改为['index2']和['login2']为不存在的名称，会发生什么？ 结果打包生成的index.html和login.html中没有引用任何js文件。 总结一下，chunks为entry里指定的2个名称，分别为index和login。所以只能指定这2个，如不设置会引入所有的chunks。打包时，控制台会显示chunks信息： 除了entry里生成chunks，还有其他，推荐阅读《Webpack 理解 Chunk》。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-04 13:40:47 "},"webpack/7_splitChunks.html":{"url":"webpack/7_splitChunks.html","title":"splitChunks","keywords":"","body":"Split Chunks 基于上个例子，我们做一些修改。main.js和login.js同时引用一些公共代码，看看打包结果。 修改文件 首先安装一个第三方依赖jscookie： npm i -d jscookie 修改main.js const show = require('./show.js') const jsCookie = require('jscookie') show('index') jsCookie.set({name: 'name', value: 'index'}) 修改login.js const show = require('./show.js') const jsCookie = require('jscookie') show('login') jsCookie.set({name: 'name', value: 'login'}) 完成后，打包发现： 公共代码show.js和jscookie同时在index.js和login.js里，换句话说存在冗余代码！ 如何解决这个问题？ optimization.splitChunks可以解决这个问题。 提取公共代码 修改webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', devServer: { open: true }, entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, optimization: { splitChunks: { chunks: 'all', minSize: 0, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: 'chunk-vendor' }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, name: 'chunk-common' } } }, }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }), new CleanWebpackPlugin() ] } 关键代码在13-31行optimization属性，用于代码优化。其中splitChunks用于代码分块配置，具体可以参考：《Webpack官网文档》以及《split-chunks-plugin》。 打包后，我们发现dist目录多出了chunk-vendor.js和chunk-common.js。公共代码成功提取！ jscooke的代码在chunk-vendor.js中，是因为匹配中了cacheGroups.vendors.test规则。 show.js的代码匹配中了cacheGroups.default.minChunks规则。minChunks为2表示，只要同一代码被引用超过2次，则提取出来放在chunk-common中。我们可以试验一下，将其改为3，重新打包发现没有chunk-common.js文件，show.js代码分别在index.js和login.js中。 minSize是指公共代码的大小，为0表示任何功能代码都需要拆分。如果指定为1024（单位是bytes），即1kb，如果公共代码的文件大小小于1kb，那么也不会被抽取。我们可以将其改为2048试试。 发现问题 虽然公共代码提取成功了，但是打开index.html和login.html文件，我们发现页面并没有显示文字，而是空白！说明存在问题！ 分析一下： 代码拆分已经完成。 打开login.html发现引入了login.js，但是没有引入chunk-common.js和chunk-vendor.js。所以导致没有执行到show.js中的代码。 解决 问题原因是在HtmlWebpackPlugin中chunks的配置！ 由于之前的demo没有做代码拆分，所以一个entry就是一个chunk，没有问题。现在代码拆分为多个chunk了，所以在HtmlWebpackPlugin.chunks的配置也要指定公共代码chunk。 修改代码如下： plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index', 'chunk-common', 'chunk-vendor'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login', 'chunk-common', 'chunk-vendor'] }), new CleanWebpackPlugin() ] 在生成index.html和login.html时，指定chunks，打包后页面可正常显示！另外注意： 注意缓存，清空缓存后刷新。 由于使用了cookie，所以如果要检查cookie是否生成，需要通过http发布页面，推荐http-server。 到此，我们完成了公共代码的提取！ 参考资料 《Webpack Optimize》 《split-chunks-plugin》 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:53:31 "},"js/":{"url":"js/","title":"JavaScipt记录","keywords":"","body":"JavaScript积累 记录js项目和学习中所得。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:34:41 "},"js/code-snippets.html":{"url":"js/code-snippets.html","title":"代码片段","keywords":"","body":"代码片段 统计字符串中某段字符出现的次数 常规方法通过for循环计数，返回结果，这里不再赘述。下面介绍2种方法： 调用String的match方法。如： var str = 'This is my code snippets. He is not my friend. She is a good girl.' // 统计is出现的次数 function occurCount (baseStr, targetStr) { let reg = new RegExp(targetStr, 'g') return (baseStr.match(reg) || []).length } 借用split方法拆分 function occurCount (baseStr, targetStr) { return baseStr.split(targetStr).filter(i => i.trim().length > 0).length } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:48:13 "},"less-sass/":{"url":"less-sass/","title":"SASS & LESS记录","keywords":"","body":"SASS & LESS记录 背景 SASS和LESS均是CSS样式处理，本篇记录项目中的常见问题和用法。 本人在H3C项目中使用的是LESS，在目前Zoom使用的SASS。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:26:36 "},"less-sass/variable-trans.html":{"url":"less-sass/variable-trans.html","title":"变量转义","keywords":"","body":"变量转义 在LESS和SASS中有时需要对变量进行转义。 SASS 比如，在SASS中如用到calc计算属性时： $container-width: 200px; width: calc(100% - $container-width); 上述代码运行结果不正确，发现container-width并没有转为200px，而是直接显示了。 这时就需要转义，正确代码如下： $container-width: 200px; width: calc(100% - #{$container-width}); 在变量外包上#{}，即可实现变量转义。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:22:37 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 主要记录一些无分类的文章。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 15:00:39 "},"other/accessbility.html":{"url":"other/accessbility.html","title":"Accessbility","keywords":"","body":"Accessbility 概念 Accessibility，通常缩写为 A11Y ，这缩写取的是首字母 + 中间字母长度 + 结尾字母，译为 “可访问性”。这是一种让尽可能多的人访问我们所开发的网站的技术概念，通过这个概念，让互联网访问公平变得可能。 CheckList 为任何非文本内容提供文本替代项 img标签添加alt属性 alt有时需要设置为空，避免重复。如下，假如img的alt仍设置为搜索，那么与后面的文字冲突。正确做法置空会跳过，屏幕阅读器将拾取span标签内有效的“搜索”一词并朗读。 搜索 表单 使用 label 的for属性绑定控件元素的id This is a checkbox aria-required和aria-invalid * Name: Phone: * E-mail: var validate = function () { var emailElement = document.getElementById(emailFieldId); var valid = emailValid(formData.email); // returns true if valid, false otherwise emailElement.setAttribute(\"aria-invalid\", !valid); setElementBorderColour(emailElement, valid); // sets the border to red if second arg is false }; TabIndex 正确的 Tab 键顺序，也就是设计出来的 Tab 键的顺序需要遵循正常的视觉顺序，从上至下，从左至右，比如这张图。 Use WAI-ARIA ARIA 全称 Accessible Rich Internet Applications，可以修改现有元素的语义，也 可以向不存在原生语义的元素添加语义，在复杂的 UI 控件会涉及到非语义的 HTML，这时候通过增加浏览器和辅助技术可以识别和使用的进一步语义来让用户知道正在发生的事情。 role 如果使用的是原生支持的语义化标签，那本身就是有默认的 role的，比如 button 的 role 就是 button。如果我们使用 Div + style 来实现一个button，那就需要考虑加 role 了。 aria-label 如果我们有一个按钮，其上的 text 是个 x，代表关闭的意思，如果只是使用普通的标签，这时候，辅助设备是无法识别这个 x 的含义表达给用户的，这时候就需要添加 aria-label = 'close'，这时候屏幕阅读器就会将这个 close 阅读给用户，但不会在视觉上有任何的影响。 aria-labelledby 和中的for类似，只不过aria-labelledby用于放在控件中，如下： Lunch Options Thai Subway Radio Maria aria-hidden 当网站弹出一个模态框的时候，我们几乎是看不清除模态框以外的元素的，也是不能和其交互的。但对于使用屏幕阅读器的用户怎么办呢？因为如果你不加任何 ARIA 标签，他们默认还是会听到每个元素的解读，这时候你就需要使用 aria-hidden 来屏蔽掉除模态框以外的 DOM。 参考资料 不能永远忽略的 Accessibility (上) 不能永远忽略的 Accessibility (下) Web开发中最该知道却从不重视的 —— Accessibility Arial - Forms - Basic form hints Arial - Forms - Alerts The problem Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 15:07:14 "}}
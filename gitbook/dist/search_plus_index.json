{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本篇Gitbook主要记录本人在项目中遇到的问题，以及学习中的总结。 本人岗位为前端开发，主要技术栈： VueJs Webpack NodeJS Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:30:54 "},"webpack/":{"url":"webpack/","title":"Webpack教程","keywords":"","body":"Webpack教程 背景 Webpack从零开始，由浅入深，结合实例，逐步上手掌握。阅读建议：从第一篇开始，按顺序阅读。 教程环境 node12.20.2webpack5.23.0webpack-cli4.5.0 官网文档 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:33:02 "},"webpack/1_HelloWebpack.html":{"url":"webpack/1_HelloWebpack.html","title":"Hello Webpack","keywords":"","body":"Hello Webpack 文件列表： 总共4个文件： index.html 1.3.3 使用Webpack main.js import {show} from './show.js' show('Webpack') show.js export function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/2_CssLoader.html":{"url":"webpack/2_CssLoader.html","title":"Css Loader","keywords":"","body":"Css Loader 基于上个例子，我们加一点css样式。 修改文件 增加style.css #app { font-size: 25px; font-weight: bolder; color: blue; } 修改main.js require('./style.css') import {show} from './show.js' show('Webpack') 增加第1行，引入css文件。注意这里是通过js代码引入的，而不是html文件中通过link引入。 修改webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] } } 其中9-16行，为新加配置。主要作用是为css文件指定了Loader，因为webpack只能解析js文件，所以我们要使用style-loader和css-loader对css文件解析。同时别忘了安装这2个插件，安装命令： npm init npm install -D style-loader css-loader Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： 打开bundle.js文件，我们可以发现，css代码是在js文件中，并没有生成新的css文件。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/3_Plugin.html":{"url":"webpack/3_Plugin.html","title":"Plugin","keywords":"","body":"Plugin 基于上个例子，我们把css样式从js代码中剥离出来。最终效果是，打包出来后为2个文件，js和css代码分开，通过mini-css-extract-plugin插件实现。 修改文件 修改index.html 1.3.5 使用Plugin 新增第7行代码，至于main后面的hash如何确定？最后会介绍。 修改webpack.config.js const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }) ] } 引入mini-css-extract-plugin插件，将css代码剥离出来。 别忘了安装依赖 npm install -D mini-css-extract-plugin Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.141bbd3b8e8be1b45fb5.css，打开index.html后，效果和上一个例子一致，说明css样式生效。 FAQ css文件名的问题 第一步中index.html中css文件名的问题，我们尝试以下2种修改： 将css文件名设为定值 webpack.config.js中filename直接改为style.css。 打包后，发现css文件名生效，此时记得修改index.html中css文件名，此种方法也可生效，但不推荐。 不修改文件名，修改css内容 我们修改style.css中的内容，任意修改，增加，删除内容。 重新打包后，发现文件名后缀hash变化了。 因为我们定义的文件名是基于文件内容的，所以一旦css文件发生变化，文件名也会变化。所以本篇一开始定义的带hash的filename并不好。因为事先我们并不知道文件名中的hash，并且文件内容一旦发生变化文件名也会变化。 filename: `[name].[contenthash].css` 那我们把后缀hash去除，试试看。 filename: `[name].css` 结果是打包生成了main.css。同时修改index.html的引用，可生效，但不推荐。 为什么要给文件名加上hash？ 为了解决引用缓存的问题。所以上面的2种解决办法不推荐，会有缓存问题。 如何解决hash文件名引入的问题？ 使用html-webpack-plugin插件，见下篇。 参考文档 npm extract-text-webpack-plugin webpack的extract-text-webpack-plugin插件 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:41:50 "},"webpack/4_html-webpack-plugin.html":{"url":"webpack/4_html-webpack-plugin.html","title":"html-webpack-plugin","keywords":"","body":"html-webpack-plugin 该插件的基本作用就是生成html文件。原理很简单： 将 webpack中entry配置的相关入口chunk 和 extract-text-webpack-plugin抽取的css样式 插入到该插件提供的template或者templateContent配置项指定的内容基础上生成一个html文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。 修改文件 修改index.html文件，去除掉对js和css文件的引用，让插件自动完成： 1.3.5 使用Plugin - html-webpack-plugin 最重要的是修改webpack.config.js，引入html-webpack-plugin插件。 const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'index.html') }) ] } 不要在意插件的位置，因为插件执行的顺序并不取决于数组中的位置，而是取决于侦听的钩子。 Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.9e4519333259a0e9bd53.css和index.html，打开index.html后，效果和上一个例子一致，说明css样式生效。 与之前不同的是，此时会生成一个新的index.html文件。该文件是基于template指定的文件，将js和css文件以script和link引入生成的新文件，这就是html-webpack-plugin插件的作用！ 参考文档 npm html-webpack-plugin html-webpack-plugin详解 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:39:28 "},"webpack/5_devServer.html":{"url":"webpack/5_devServer.html","title":"devServer","keywords":"","body":"devServer devServer是Webpack的功能之一，可以实现： 发布文件 热更新 修改文件 修改webpack.config.js，增加一行devServer的配置： module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), devServer: { open: true }, // ... } 安装webpack-dev-server插件 npm install -g webpack-dev-server Webpack build 运行命令有变化： webpack-dev-server --hot --devtool source-map 运行成功后，会自动打开页面，如下效果： 和之前有以下变化： 最直观的，页面会自动打开。 地址栏中不再是本地文件路径，而是localhost:8080。 修改show.js文件，先自动打包，然后页面会自动刷新生效。 FAQ 修改style.css文件为什么页面不会自动刷新？ 见Webpack官方文档中的解释《MiniCssExtractPlugin》 所以，如果想让css修改实时刷新，修改webpack.config.js，重新打包后生效！ const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [ isDevMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader' ], } ] }, // ... } 二者有什么不同呢？ 开发环境使用style-loader，直接将css注入到head标签内，如下图： 生成环境使用mini-css-extract-plugin，将css代码剥离。 有没有其他办法解决？ 除了上面官方的方法外，还有一种办法是改变filename。 修改webpack.config.js文件： const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ], plugins: [ new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }), // ... ] } } 思路是，开发环境下固定住css文件的文件名。这样css文件修改后，能实现自动更新。而且不会有缓存问题，因为webpack-dev-server会自动在后追加时间戳的hash： 由此推断第一个问题的原因是css文件名hash变化，html中引用css的文件名没有及时更新。我们将filename改为cotenthash，修改css中的颜色，之后如下图： 我们发现： webpack确实侦听到变化，并且重新打包了。css文件名由main.9e4519333259a0e9bd53.css变为main.c9189b62182a414e712f.css。 页面DOM也发生变化了，首先css文件名后多了时间戳，说明更新了css文件。另外多了一个js文件main.cc05876de95eea54c5bb.hot-update.js的引用，这个文件的作用正是刷新页面。 但是为什么页面中样式没有更新？ 我们看这个main.cc05876de95eea54c5bb.hot-update.js文件内容，并未包含最新的css文件名，所以页面无法更新css样式。而问题2的解决办法正是去除hash的影响。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 09:15:30 "},"webpack/6_multipleEntry.html":{"url":"webpack/6_multipleEntry.html","title":"Multiple Entry","keywords":"","body":"Multiple Entry Webpack支持多入口文件的打包。多入口意味着入口文件也是多个。 修改文件 准备以下5个文件 index.html show.js export function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show main.js import {show} from './show.js' show('index') login.js import {show} from './show.js' show('login') webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }) ] } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成4个新文件：index.html、login.html、index.js、login.js。分别打开2个html文件，发现内容生效。 总结 总结以下几点 title的设置 webpack.config.js中设置title，在index.html中读取title。 chunks的作用 把webpack.config.js中2的chunks的配置删除，打包后会发生什么？ 结果打包生成的index.html和login.html中均引用了index.js和login.js。 修改chunks，如改为['index2']和['login2']为不存在的名称，会发生什么？ 结果打包生成的index.html和login.html中没有引用任何js文件。 总结一下，chunks为entry里指定的2个名称，分别为index和login。所以只能指定这2个，如不设置会引入所有的chunks。打包时，控制台会显示chunks信息： 除了entry里生成chunks，还有其他，推荐阅读《Webpack 理解 Chunk》。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/7_splitChunks.html":{"url":"webpack/7_splitChunks.html","title":"splitChunks","keywords":"","body":"Split Chunks 基于上个例子，我们做一些修改。main.js和login.js同时引用一些公共代码，看看打包结果。 修改文件 首先安装一个第三方依赖jscookie： npm i -d jscookie 修改main.js import {show} from './show.js' const jsCookie = require('jscookie') show('index') jsCookie.set({name: 'name', value: 'index'}) 修改login.js import {show} from './show.js' const jsCookie = require('jscookie') show('login') jsCookie.set({name: 'name', value: 'login'}) 完成后，打包发现： 公共代码show.js和jscookie同时在index.js和login.js里，换句话说存在冗余代码！ 如何解决这个问题？ optimization.splitChunks可以解决这个问题。 提取公共代码 修改webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', devServer: { open: true }, entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, optimization: { splitChunks: { chunks: 'all', minSize: 0, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: 'chunk-vendor' }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, name: 'chunk-common' } } }, }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }), new CleanWebpackPlugin() ] } 关键代码在13-31行optimization属性，用于代码优化。其中splitChunks用于代码分块配置，具体可以参考：《Webpack官网文档》以及《split-chunks-plugin》。 打包后，我们发现dist目录多出了chunk-vendor.js和chunk-common.js。公共代码成功提取！ jscooke的代码在chunk-vendor.js中，是因为匹配中了cacheGroups.vendors.test规则。 show.js的代码匹配中了cacheGroups.default.minChunks规则。minChunks为2表示，只要同一代码被引用超过2次，则提取出来放在chunk-common中。我们可以试验一下，将其改为3，重新打包发现没有chunk-common.js文件，show.js代码分别在index.js和login.js中。 minSize是指公共代码的大小，为0表示任何功能代码都需要拆分。如果指定为1024（单位是bytes），即1kb，如果公共代码的文件大小小于1kb，那么也不会被抽取。我们可以将其改为2048试试。 发现问题 虽然公共代码提取成功了，但是打开index.html和login.html文件，我们发现页面并没有显示文字，而是空白！说明存在问题！ 分析一下： 代码拆分已经完成。 打开login.html发现引入了login.js，但是没有引入chunk-common.js和chunk-vendor.js。所以导致没有执行到show.js中的代码。 解决 问题原因是在HtmlWebpackPlugin中chunks的配置！ 由于之前的demo没有做代码拆分，所以一个entry就是一个chunk，没有问题。现在代码拆分为多个chunk了，所以在HtmlWebpackPlugin.chunks的配置也要指定公共代码chunk。 修改代码如下： plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index', 'chunk-common', 'chunk-vendor'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login', 'chunk-common', 'chunk-vendor'] }), new CleanWebpackPlugin() ] 在生成index.html和login.html时，指定chunks，打包后页面可正常显示！另外注意： 注意缓存，清空缓存后刷新。 由于使用了cookie，所以如果要检查cookie是否生成，需要通过http发布页面，推荐http-server。 到此，我们完成了公共代码的提取！ 参考资料 《Webpack Optimize》 《split-chunks-plugin》 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/8_loader.html":{"url":"webpack/8_loader.html","title":"Loader","keywords":"","body":"Loader 假如我们想用less或者sass等css预处理工具时，就需要配置loader，来解析*.less或*.scss文件。因为webpack只能识别js文件，其它格式的文件，需要调用其他“翻译员”进行处理。 文件代码 本篇以less为例，首先需要安装依赖： npm install less less-loader@5.0.0 less-loader指定版本，因为其他版本可能有bug，打包过程报错。 5个文件： index.html less-loader style.less #app { font-size: 25px; font-weight: bolder; color: orange; } show.js function show (content) { document.getElementById('app').innerText = 'Hello, my friend, ' + content } module.exports = show main.js require('./style.less') const show = require('./show') show('Webpack-dev-server') webpack.config.js const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const isDevMode = process.env.NODE_ENV !== 'production' module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), devServer: { open: true }, output: { filename: 'bundle.[hash:8].js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], } ] }, plugins: [ new CleanWebpackPlugin(), new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'index.html') }) ] } 打包 这里我们用webpack-dev-server启动： webpack-dev-server --watch --hot --devtool source-map 成功效果： 分析 这里配置less-loader的代码主要是： module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }) ] 其中： test配置的是匹配规则，匹配*.css和*.less文件。 use里指明了3种loader，处理过程是（注意是从右往左的顺序）： 先将LESS源码提交给less-loader处理，将LESS转换为CSS。 再交给css-loader处理，主要做：找出css代码中依赖的资源、压缩代码等。 最后再交给MiniCssExtractPlugin插件中的Loader处理，这里主要是将css代码分离出单独文件。配合plugins中的MiniCssExtractPlugin。rules和plugins中两处配置缺一不可。 由上面的例子可以看出，一个Loader的职责是单一的，只需要完成一种转换。如果一个源文件需要经历多步转换才能正常使用，就通过多个Loader去转换。所以，在开发一个Loader时，请保持其功能的单一性，我们只需关心输入和输出。 手写一个Loader Loader实例 一个最简单的Loader的源码如下： module.exports = function (source) { // source即文件内容,可自行处理 return source } 自定义Loader场景 接下来我们假设一个场景： 引入新的*.ls格式文件。 ls文件内语法我们可以自行定义： 支持3种功能：控制台打印、alert以及页面显示文本。对应的命令分别为：c、a、s。 语法格式为： c:Hello a:World s:New_Loader 多个命令空格隔开，单个命令单元首位是命令缩写字母，冒号隔开，冒号后是内容。 我们已经创造了这种独一无二的ls语法，如何让我们的页面用到它呢？ 首先我们新建一个文件loader-parse.ls c:Hello a:World s:New_Loader 然后新建我们的loader文件ls-loader.js，内容先空着。 然后在webpack.config.js配置中，增加对ls的解析： module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], }, { test: /\\.ls$/i, use: 'ls-loader' } ] }, resolveLoader: { modules: ['./node_modules', './'] }, 分析： rules中的规则简单，不用多说。 resolveLoader是告诉webpack，loader先去node_modules中搜索，没有的话再去当前文件夹内搜索。user中的值要和我们的loader文件名相同，否则搜索不到。 最后我们来完成loader的处理逻辑，其实也简单。因为参数source就是我们ls文件内容，只需要针对我们的语法进行处理即可，代码参考如下： module.exports = function (source) { let arr = source.split(/\\s+/) let result = [] arr.forEach(item => { console.log(item) const command = item.split(':')[0] const content = item.split(':')[1] const map = { c: function (content) { return `console.log('${content}')` }, a: function (content) { return `alert('${content}')` }, s: function (content) { return `document.getElementsByTagName('body')[0].appendChild(document.createTextNode('${content}'))` } } if (map[command]) { result.push(map[command](content)) } }) return result.join(';\\n') } 检验自定义Loader 运行： webpack-dev-server --watch --hot --devtool source-map ls代码被执行，并且翻译成功！ Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 19:11:00 "},"js/":{"url":"js/","title":"JavaScipt记录","keywords":"","body":"JavaScript积累 记录js项目和学习中所得。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:34:41 "},"js/code-snippets.html":{"url":"js/code-snippets.html","title":"代码片段","keywords":"","body":"代码片段 统计字符串中某段字符出现的次数 常规方法通过for循环计数，返回结果，这里不再赘述。下面介绍2种方法： 调用String的match方法。如： var str = 'This is my code snippets. He is not my friend. She is a good girl.' // 统计is出现的次数 function occurCount (baseStr, targetStr) { let reg = new RegExp(targetStr, 'g') return (baseStr.match(reg) || []).length } 借用split方法拆分 function occurCount (baseStr, targetStr) { return baseStr.split(targetStr).filter(i => i.trim().length > 0).length } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:48:13 "},"js/regex-assertions.html":{"url":"js/regex-assertions.html","title":"正则表达式断言","keywords":"","body":"正则表达式之断言Assertion 零宽正向先行断言 表达式：x(?=y) 含义：仅匹配被y跟随的x Demo：匹配后缀名为jpg的文件名 `demo1.mpg demo2.png demo3.txt demo4.jpg demo5.gif demo6.js demo7.jpg`.match(/\\w+(?=\\.jpg)/g) 零宽度负向先行断言 表达式：x(?!y) 含义：仅匹配不被y跟随的x Demo：匹配后缀名不为jpg的文件名 `demo1.mpg demo2.png demo3.txt demo4.jpg demo5.gif demo6.js demo7.jpg`.split(' ').filter(file => /\\w+\\.(?!jpg)/.test(file)) 零宽度正向回顾断言 表达式：(? 含义：x只有在y后面才匹配 Demo：匹配苹果手机的型号 ['Apple 11', 'Mi 12', 'Huawei Nova', 'Apple 12 Pro', 'Vivo X11'].filter(item => /(? 零宽度负向回顾断言 表达式：(? 含义：x只有不在y后面才匹配 说明：JavaScript中不支持！ Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-22 10:09:11 "},"less-sass/":{"url":"less-sass/","title":"CSS & SASS & LESS记录","keywords":"","body":"SASS & LESS记录 背景 SASS和LESS均是CSS样式处理，本篇记录项目中的常见问题和用法。 本人在H3C项目中使用的是LESS，在目前Zoom使用的SASS。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:26:36 "},"less-sass/variable-trans.html":{"url":"less-sass/variable-trans.html","title":"变量转义","keywords":"","body":"变量转义 在LESS和SASS中有时需要对变量进行转义。 SASS 比如，在SASS中如用到calc计算属性时： $container-width: 200px; width: calc(100% - $container-width); 上述代码运行结果不正确，发现container-width并没有转为200px，而是直接显示了。 这时就需要转义，正确代码如下： $container-width: 200px; width: calc(100% - #{$container-width}); 在变量外包上#{}，即可实现变量转义。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:22:37 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 主要记录一些无分类的文章。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 15:00:39 "},"other/A11Y/":{"url":"other/A11Y/","title":"Accessbility","keywords":"","body":"Accessbility 概念 Accessibility，通常缩写为 A11Y ，这缩写取的是首字母 + 中间字母长度 + 结尾字母，译为 “可访问性”。这是一种让尽可能多的人访问我们所开发的网站的技术概念，通过这个概念，让互联网访问公平变得可能。 在国内A11Y在前端领域极易被忽略，也是一块技术冷门。在面试中极少会被问到，而在国外特别是受众比较广泛的前端应用，A11Y必不可少。虽然它不直接影响页面功能，但是没有它会极大影响有障碍的用户来访问我们的页面。 本篇记录本人在项目中从零开始，学习和应用A11Y的领悟，亦可作为新手学习入门的教程。 参考资料 不能永远忽略的 Accessibility (上) 不能永远忽略的 Accessibility (下) Web开发中最该知道却从不重视的 —— Accessibility Arial - Forms - Basic form hints Arial - Forms - Alerts The problem Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 17:59:13 "},"other/A11Y/landmarks.html":{"url":"other/A11Y/landmarks.html","title":"Landmarks","keywords":"","body":"LandMarks 前端开发人员写html时，很容易滥用标签，然而除了还有很多其它好用的标签。 下图是一个非常常见的页面结构： 以Header为例，我们写html时通常会怎么写？相信大部分人都会习惯性地这么编码： 假如我们使用了更合适的标签的话，代码变得更语义化，生动了。 什么是LandMark Landmark英文翻译是路标、地标。在html中，我们可以理解为语义化的标签，即见名知意的标签。 为什么推荐用 无论使用和，都可以实现我们的页面效果。但是这里讨论的是Accessbility，即让有某些障碍的用户能够更加方便地访问我们的页面。接下来，告诉你为什么要用。 使用第三方工具NVDA（有视觉障碍的用户，会使用类似工具软件，通过读屏的方式来浏览我们的页面，即screen reader users）。通过inseet+F7可以调出下面对话框。在Landmarks中，可见当前页面的结构： 如果只使用标签的话，这里完全看不出页面的结构，视障用户也很难定位到header或者footer元素。所以改掉原来的坏习惯，推荐用如下标签：,,,等。 假如因为某些原因不能使用这些标签的话，你可以增加WAI-ARIA的role属性来实现同样的目的。 Bad Good Awesome 常见的role banner 通常指页面的头部，即。 complementary 译为“补充的”，即页面的补充信息。如下图，页面的相关参考文档用了标签，这样landmarks工具就能抓取到该区域。同时增加了aria-labelledby指定了标签的id，从而进一步抓取到Related Documents文本。这样，极大地方便了视障用户获取该区域的信息。 标签默认的role为complementary。假如其他标签需要实现该role的话，可以： Title for complementary area contentinfo 一般为底部的用于展示页面基本信息的元素，通常称为。 form 顾名思义，即页面中的表单。如果用的是标签，那么不需要指定role；否则，则需要增加： Register Form 除此之外，还有几点需要注意： 如果页面包含多个form，那么如何区分？ 建议为每个form设置不同的aria-labelledby，这样读屏软件可以区分不同的form。 假如表单是完成搜索功能，那么建议role=\"search\"。 表单中的输入控件，最好也设置单独的role 如：button，input，select，textarea等。 main 每个页面至少有一个main。作用是展示页面的主要内容。 main应当在最外层。 假如有多个main，可以用aria-labelledby区分。 navigation 用于页面导航。 region 便于用户灵活定义功能区域，默认标签为。 title for main content area title for region area 1 title for region area 2 上面的例子，通过landmarks抓取到的结构： 还有另外3种写法，均可实现相同的效果，供参考： 使用标签 title for region area 1 使用aria-label title for region area 1 使用title title for region area 1 search 搜索功能的区域，使用role=\"search\"。 总结 区分role和tag的关系： Landmarks Role HTML Tag banner complementary form main navigation region search none 如果使用了右侧的默认标签，则不需要额外写role。否则，需要手动加上role。 banner，main，complementary和contentinfo这4个landmarks必须在最外层。 假如页面包含多个role，需要用label或者aria-labelledby或者title加以区分。 参考资料 ARIA Landmarks A11Y-101 - Landmarks Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 17:55:06 "},"webpack/async-in-vue-cli3.html":{"url":"webpack/async-in-vue-cli3.html","title":"vue.config.js中chainWebpack支持异步数","keywords":"","body":"vue.config.js中chainWebpack支持异步数据 前言 项目背景 项目使用vue-cli4搭建的，如需修改Webpack的配置，需要修改vue.config.js。 项目中，在chainWebpack中调用了html-webpack-plugin生成dev.html文件。 html-webpack-plugin的配置templateParameters支持模板参数注入，支持对象和方法。本文就是基于这个配置做文章。如何配置可参考：templateParameters demo 在html页面接收foo参数，即可获得bar值： 需求 需要在dev.html注入一些数据，而这些数据是异步获取的（调用接口或者其他方式）。我这里是需要通过Node.js的child_process执行git命令，获取分支信息。 尝试 templateParameters支持function。可以尝试传入async方法，通过await获取到数据后，再返回。 遇到问题 chainWebpack和templateParameters均不支持异步。 chainWebpack改为异步后，打包报错。 templateParameters改为异步后，虽不影响打包，但是变量不生效。 苦于vue-cli-service和html-webpack-plugin均不支持异步，只能另想办法。 解决 查阅资料 先通过百度，国内貌似没有类似的记录文章。然后Google，果然找到了类似需求： Vue config async support 有人提出了类似的issue，虽然作者没有直接解决，但是也给出了一个work around： 改代码 这个方法的思路，实际上将npm run serve包了一层wrap，在外层拿到数据后，再通过代码调用npm run serve开始打包。接下来我们来完成这个wrap。 首先新建一个文件serve.prehandle.js，用于wrap。先获取异步数据，待拿到之后再开始打包： const getGitDevInfo = require('./src/pages/demo/webpack-plugin/git-info') const isDevEnv = process.env.NODE_ENV !== 'production' module.exports = (api, options) => { api.registerCommand('serve:prehandle', async (args) => { if (isDevEnv) { const def = await getGitDevInfo() process.asyncParamter = def } await api.service.run('serve', args) }) } module.exports.defaultModes = { 'serve:prehandle': 'development' } 然后修改package.json 修改serve命令 { \"scripts\": { \"serve\": \"vue-cli-service serve:prehandle\" } } 增加vuePlugins，对应上面的serve.prehandle命令，为这条命令指定处理文件 { \"vuePlugins\": { \"service\": [\"serve.prehandle.js\"] } } 修改vue.config.js去接收数据。这里我存在process全局变量中： config.plugin('html').use(HtmlWebpackPlugin, [{ filename: 'dev.html', template: 'src/pages/demo/index.html', templateParameters: { config: `window.devGitInfo=${JSON.stringify(process.asyncParamter || {})}` }, chunks: ['chunk-vendors', 'chunk-common', 'dev'], }]) 接下来，执行后可生效！ npm run serve 相关知识点 vue-cli Service Plugin vue-cli支持导入自定义的Service Plugin，具体参考下面文档： Project local plugin Add a new cli-service command Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-18 10:04:33 "}}
{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本篇Gitbook主要记录本人在项目中遇到的问题，以及学习中的总结。 本人岗位为前端开发，主要技术栈： VueJs Webpack NodeJS Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-22 10:11:36 "},"webpack/":{"url":"webpack/","title":"Webpack教程","keywords":"","body":"Webpack教程 背景 Webpack从零开始，由浅入深，结合实例，逐步上手掌握。阅读建议：从第一篇开始，按顺序阅读。 教程环境 node12.20.2webpack5.23.0webpack-cli4.5.0 官网文档 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:33:02 "},"webpack/1_HelloWebpack.html":{"url":"webpack/1_HelloWebpack.html","title":"Hello Webpack","keywords":"","body":"Hello Webpack 文件列表： 总共4个文件： index.html 1.3.3 使用Webpack main.js import {show} from './show.js' show('Webpack') show.js export function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/2_CssLoader.html":{"url":"webpack/2_CssLoader.html","title":"Css Loader","keywords":"","body":"Css Loader 基于上个例子，我们加一点css样式。 修改文件 增加style.css #app { font-size: 25px; font-weight: bolder; color: blue; } 修改main.js require('./style.css') import {show} from './show.js' show('Webpack') 增加第1行，引入css文件。注意这里是通过js代码引入的，而不是html文件中通过link引入。 修改webpack.config.js const path = require('path') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'css-loader'] } ] } } 其中9-16行，为新加配置。主要作用是为css文件指定了Loader，因为webpack只能解析js文件，所以我们要使用style-loader和css-loader对css文件解析。同时别忘了安装这2个插件，安装命令： npm init npm install -D style-loader css-loader Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js，打开index.html后，效果如下： 打开bundle.js文件，我们可以发现，css代码是在js文件中，并没有生成新的css文件。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/3_Plugin.html":{"url":"webpack/3_Plugin.html","title":"Plugin","keywords":"","body":"Plugin 基于上个例子，我们把css样式从js代码中剥离出来。最终效果是，打包出来后为2个文件，js和css代码分开，通过mini-css-extract-plugin插件实现。 修改文件 修改index.html 1.3.5 使用Plugin 新增第7行代码，至于main后面的hash如何确定？最后会介绍。 修改webpack.config.js const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }) ] } 引入mini-css-extract-plugin插件，将css代码剥离出来。 别忘了安装依赖 npm install -D mini-css-extract-plugin Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.141bbd3b8e8be1b45fb5.css，打开index.html后，效果和上一个例子一致，说明css样式生效。 FAQ css文件名的问题 第一步中index.html中css文件名的问题，我们尝试以下2种修改： 将css文件名设为定值 webpack.config.js中filename直接改为style.css。 打包后，发现css文件名生效，此时记得修改index.html中css文件名，此种方法也可生效，但不推荐。 不修改文件名，修改css内容 我们修改style.css中的内容，任意修改，增加，删除内容。 重新打包后，发现文件名后缀hash变化了。 因为我们定义的文件名是基于文件内容的，所以一旦css文件发生变化，文件名也会变化。所以本篇一开始定义的带hash的filename并不好。因为事先我们并不知道文件名中的hash，并且文件内容一旦发生变化文件名也会变化。 filename: `[name].[contenthash].css` 那我们把后缀hash去除，试试看。 filename: `[name].css` 结果是打包生成了main.css。同时修改index.html的引用，可生效，但不推荐。 为什么要给文件名加上hash？ 为了解决引用缓存的问题。所以上面的2种解决办法不推荐，会有缓存问题。 如何解决hash文件名引入的问题？ 使用html-webpack-plugin插件，见下篇。 参考文档 npm extract-text-webpack-plugin webpack的extract-text-webpack-plugin插件 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:41:50 "},"webpack/4_html-webpack-plugin.html":{"url":"webpack/4_html-webpack-plugin.html","title":"html-webpack-plugin","keywords":"","body":"html-webpack-plugin 该插件的基本作用就是生成html文件。原理很简单： 将 webpack中entry配置的相关入口chunk 和 extract-text-webpack-plugin抽取的css样式 插入到该插件提供的template或者templateContent配置项指定的内容基础上生成一个html文件，具体插入方式是将样式link插入到head元素中，script插入到head或者body中。 修改文件 修改index.html文件，去除掉对js和css文件的引用，让插件自动完成： 1.3.5 使用Plugin - html-webpack-plugin 最重要的是修改webpack.config.js，引入html-webpack-plugin插件。 const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: `[name].[contenthash].css` }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'index.html') }) ] } 不要在意插件的位置，因为插件执行的顺序并不取决于数组中的位置，而是取决于侦听的钩子。 Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成新文件bundle.js和main.9e4519333259a0e9bd53.css和index.html，打开index.html后，效果和上一个例子一致，说明css样式生效。 与之前不同的是，此时会生成一个新的index.html文件。该文件是基于template指定的文件，将js和css文件以script和link引入生成的新文件，这就是html-webpack-plugin插件的作用！ 参考文档 npm html-webpack-plugin html-webpack-plugin详解 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-20 16:39:28 "},"webpack/5_devServer.html":{"url":"webpack/5_devServer.html","title":"devServer","keywords":"","body":"devServer devServer是Webpack的功能之一，可以实现： 发布文件 热更新 修改文件 修改webpack.config.js，增加一行devServer的配置： module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), devServer: { open: true }, // ... } 安装webpack-dev-server插件 npm install -g webpack-dev-server Webpack build 运行命令有变化： webpack-dev-server --hot --devtool source-map 运行成功后，会自动打开页面，如下效果： 和之前有以下变化： 最直观的，页面会自动打开。 地址栏中不再是本地文件路径，而是localhost:8080。 修改show.js文件，先自动打包，然后页面会自动刷新生效。 FAQ 修改style.css文件为什么页面不会自动刷新？ 见Webpack官方文档中的解释《MiniCssExtractPlugin》 所以，如果想让css修改实时刷新，修改webpack.config.js，重新打包后生效！ const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [ isDevMode ? 'style-loader' : MiniCssExtractPlugin.loader, 'css-loader' ], } ] }, // ... } 二者有什么不同呢？ 开发环境使用style-loader，直接将css注入到head标签内，如下图： 生成环境使用mini-css-extract-plugin，将css代码剥离。 有没有其他办法解决？ 除了上面官方的方法外，还有一种办法是改变filename。 修改webpack.config.js文件： const isDevMode = process.env.NODE_ENV !== 'production' // ... module.exports = { module: { rules: [ { test: /\\.css$/i, use: [MiniCssExtractPlugin.loader, 'css-loader'], } ], plugins: [ new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }), // ... ] } } 思路是，开发环境下固定住css文件的文件名。这样css文件修改后，能实现自动更新。而且不会有缓存问题，因为webpack-dev-server会自动在后追加时间戳的hash： 由此推断第一个问题的原因是css文件名hash变化，html中引用css的文件名没有及时更新。我们将filename改为cotenthash，修改css中的颜色，之后如下图： 我们发现： webpack确实侦听到变化，并且重新打包了。css文件名由main.9e4519333259a0e9bd53.css变为main.c9189b62182a414e712f.css。 页面DOM也发生变化了，首先css文件名后多了时间戳，说明更新了css文件。另外多了一个js文件main.cc05876de95eea54c5bb.hot-update.js的引用，这个文件的作用正是刷新页面。 但是为什么页面中样式没有更新？ 我们看这个main.cc05876de95eea54c5bb.hot-update.js文件内容，并未包含最新的css文件名，所以页面无法更新css样式。而问题2的解决办法正是去除hash的影响。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-02-22 09:15:30 "},"webpack/6_multipleEntry.html":{"url":"webpack/6_multipleEntry.html","title":"Multiple Entry","keywords":"","body":"Multiple Entry Webpack支持多入口文件的打包。多入口意味着入口文件也是多个。 修改文件 准备以下5个文件 index.html show.js export function show (content) { document.getElementById('app').innerText = 'Hellow,' + content } module.exports = show main.js import {show} from './show.js' show('index') login.js import {show} from './show.js' show('login') webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { mode: 'development', entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }) ] } Webpack build 运行命令： webpack --config webpack.config.js 运行成功后，会生成dist目录，该目录下生成4个新文件：index.html、login.html、index.js、login.js。分别打开2个html文件，发现内容生效。 总结 总结以下几点 title的设置 webpack.config.js中设置title，在index.html中读取title。 chunks的作用 把webpack.config.js中2的chunks的配置删除，打包后会发生什么？ 结果打包生成的index.html和login.html中均引用了index.js和login.js。 修改chunks，如改为['index2']和['login2']为不存在的名称，会发生什么？ 结果打包生成的index.html和login.html中没有引用任何js文件。 总结一下，chunks为entry里指定的2个名称，分别为index和login。所以只能指定这2个，如不设置会引入所有的chunks。打包时，控制台会显示chunks信息： 除了entry里生成chunks，还有其他，推荐阅读《Webpack 理解 Chunk》。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/7_splitChunks.html":{"url":"webpack/7_splitChunks.html","title":"splitChunks","keywords":"","body":"Split Chunks 基于上个例子，我们做一些修改。main.js和login.js同时引用一些公共代码，看看打包结果。 修改文件 首先安装一个第三方依赖jscookie： npm i -d jscookie 修改main.js import {show} from './show.js' const jsCookie = require('jscookie') show('index') jsCookie.set({name: 'name', value: 'index'}) 修改login.js import {show} from './show.js' const jsCookie = require('jscookie') show('login') jsCookie.set({name: 'name', value: 'login'}) 完成后，打包发现： 公共代码show.js和jscookie同时在index.js和login.js里，换句话说存在冗余代码！ 如何解决这个问题？ optimization.splitChunks可以解决这个问题。 提取公共代码 修改webpack.config.js const path = require('path') var HtmlWebpackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'development', devServer: { open: true }, entry: { index: path.resolve(__dirname, 'main.js'), login: path.resolve(__dirname, 'login.js') }, optimization: { splitChunks: { chunks: 'all', minSize: 0, cacheGroups: { vendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: 'chunk-vendor' }, default: { minChunks: 2, priority: -20, reuseExistingChunk: true, name: 'chunk-common' } } }, }, plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login'] }), new CleanWebpackPlugin() ] } 关键代码在13-31行optimization属性，用于代码优化。其中splitChunks用于代码分块配置，具体可以参考：《Webpack官网文档》以及《split-chunks-plugin》。 打包后，我们发现dist目录多出了chunk-vendor.js和chunk-common.js。公共代码成功提取！ jscooke的代码在chunk-vendor.js中，是因为匹配中了cacheGroups.vendors.test规则。 show.js的代码匹配中了cacheGroups.default.minChunks规则。minChunks为2表示，只要同一代码被引用超过2次，则提取出来放在chunk-common中。我们可以试验一下，将其改为3，重新打包发现没有chunk-common.js文件，show.js代码分别在index.js和login.js中。 minSize是指公共代码的大小，为0表示任何功能代码都需要拆分。如果指定为1024（单位是bytes），即1kb，如果公共代码的文件大小小于1kb，那么也不会被抽取。我们可以将其改为2048试试。 发现问题 虽然公共代码提取成功了，但是打开index.html和login.html文件，我们发现页面并没有显示文字，而是空白！说明存在问题！ 分析一下： 代码拆分已经完成。 打开login.html发现引入了login.js，但是没有引入chunk-common.js和chunk-vendor.js。所以导致没有执行到show.js中的代码。 解决 问题原因是在HtmlWebpackPlugin中chunks的配置！ 由于之前的demo没有做代码拆分，所以一个entry就是一个chunk，没有问题。现在代码拆分为多个chunk了，所以在HtmlWebpackPlugin.chunks的配置也要指定公共代码chunk。 修改代码如下： plugins: [ new HtmlWebpackPlugin({ filename: 'index.html', template: path.resolve(__dirname, 'index.html'), title: 'index', chunks: ['index', 'chunk-common', 'chunk-vendor'] }), new HtmlWebpackPlugin({ filename: 'login.html', template: path.resolve(__dirname, 'index.html'), title: 'login', chunks: ['login', 'chunk-common', 'chunk-vendor'] }), new CleanWebpackPlugin() ] 在生成index.html和login.html时，指定chunks，打包后页面可正常显示！另外注意： 注意缓存，清空缓存后刷新。 由于使用了cookie，所以如果要检查cookie是否生成，需要通过http发布页面，推荐http-server。 到此，我们完成了公共代码的提取！ 参考资料 《Webpack Optimize》 《split-chunks-plugin》 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 18:52:54 "},"webpack/8_loader.html":{"url":"webpack/8_loader.html","title":"Loader","keywords":"","body":"Loader 假如我们想用less或者sass等css预处理工具时，就需要配置loader，来解析*.less或*.scss文件。因为webpack只能识别js文件，其它格式的文件，需要调用其他“翻译员”进行处理。 文件代码 本篇以less为例，首先需要安装依赖： npm install less less-loader@5.0.0 less-loader指定版本，因为其他版本可能有bug，打包过程报错。 5个文件： index.html less-loader style.less #app { font-size: 25px; font-weight: bolder; color: orange; } show.js function show (content) { document.getElementById('app').innerText = 'Hello, my friend, ' + content } module.exports = show main.js require('./style.less') const show = require('./show') show('Webpack-dev-server') webpack.config.js const path = require('path') const MiniCssExtractPlugin = require('mini-css-extract-plugin') const HtmlWebpackPlugin = require('html-webpack-plugin') const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const isDevMode = process.env.NODE_ENV !== 'production' module.exports = { mode: 'development', entry: path.resolve(__dirname, 'main.js'), devServer: { open: true }, output: { filename: 'bundle.[hash:8].js', path: path.resolve(__dirname, 'dist') }, module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], } ] }, plugins: [ new CleanWebpackPlugin(), new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }), new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'index.html') }) ] } 打包 这里我们用webpack-dev-server启动： webpack-dev-server --watch --hot --devtool source-map 成功效果： 分析 这里配置less-loader的代码主要是： module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], } ] }, plugins: [ new MiniCssExtractPlugin({ filename: isDevMode ? `[name].css` : `[name].[contenthash].css` }) ] 其中： test配置的是匹配规则，匹配*.css和*.less文件。 use里指明了3种loader，处理过程是（注意是从右往左的顺序）： 先将LESS源码提交给less-loader处理，将LESS转换为CSS。 再交给css-loader处理，主要做：找出css代码中依赖的资源、压缩代码等。 最后再交给MiniCssExtractPlugin插件中的Loader处理，这里主要是将css代码分离出单独文件。配合plugins中的MiniCssExtractPlugin。rules和plugins中两处配置缺一不可。 由上面的例子可以看出，一个Loader的职责是单一的，只需要完成一种转换。如果一个源文件需要经历多步转换才能正常使用，就通过多个Loader去转换。所以，在开发一个Loader时，请保持其功能的单一性，我们只需关心输入和输出。 手写一个Loader Loader实例 一个最简单的Loader的源码如下： module.exports = function (source) { // source即文件内容,可自行处理 return source } 自定义Loader场景 接下来我们假设一个场景： 引入新的*.ls格式文件。 ls文件内语法我们可以自行定义： 支持3种功能：控制台打印、alert以及页面显示文本。对应的命令分别为：c、a、s。 语法格式为： c:Hello a:World s:New_Loader 多个命令空格隔开，单个命令单元首位是命令缩写字母，冒号隔开，冒号后是内容。 我们已经创造了这种独一无二的ls语法，如何让我们的页面用到它呢？ 首先我们新建一个文件loader-parse.ls c:Hello a:World s:New_Loader 然后新建我们的loader文件ls-loader.js，内容先空着。 然后在webpack.config.js配置中，增加对ls的解析： module: { rules: [ { test: /\\.(css|less)$/i, use: [ MiniCssExtractPlugin.loader, 'css-loader', 'less-loader' ], }, { test: /\\.ls$/i, use: 'ls-loader' } ] }, resolveLoader: { modules: ['./node_modules', './'] }, 分析： rules中的规则简单，不用多说。 resolveLoader是告诉webpack，loader先去node_modules中搜索，没有的话再去当前文件夹内搜索。user中的值要和我们的loader文件名相同，否则搜索不到。 最后我们来完成loader的处理逻辑，其实也简单。因为参数source就是我们ls文件内容，只需要针对我们的语法进行处理即可，代码参考如下： module.exports = function (source) { let arr = source.split(/\\s+/) let result = [] arr.forEach(item => { console.log(item) const command = item.split(':')[0] const content = item.split(':')[1] const map = { c: function (content) { return `console.log('${content}')` }, a: function (content) { return `alert('${content}')` }, s: function (content) { return `document.getElementsByTagName('body')[0].appendChild(document.createTextNode('${content}'))` } } if (map[command]) { result.push(map[command](content)) } }) return result.join(';\\n') } 检验自定义Loader 运行： webpack-dev-server --watch --hot --devtool source-map ls代码被执行，并且翻译成功！ Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-11 19:11:00 "},"js/":{"url":"js/","title":"JavaScipt记录","keywords":"","body":"JavaScript积累 记录js项目和学习中所得。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:34:41 "},"js/code-snippets.html":{"url":"js/code-snippets.html","title":"代码片段","keywords":"","body":"代码片段 统计字符串中某段字符出现的次数 常规方法通过for循环计数，返回结果，这里不再赘述。下面介绍2种方法： 调用String的match方法。如： var str = 'This is my code snippets. He is not my friend. She is a good girl.' // 统计is出现的次数 function occurCount (baseStr, targetStr) { let reg = new RegExp(targetStr, 'g') return (baseStr.match(reg) || []).length } 借用split方法拆分 function occurCount (baseStr, targetStr) { return baseStr.split(targetStr).filter(i => i.trim().length > 0).length } 产生随机数 function getRandom (min = 0, max = 10) { var dis = max - min; return Math.floor(Math.random() * (dis + 1)) + min; } 产生随机字符串 ``` ## format输出日期 ```javascript function formatDateTime (val, formatStr = 'yyyy/MM/dd hh:mm:ss') { let date = null if (typeof val === 'object' && val.getFullYear) { date = val } else if (typeof val === 'number') { date = new Date(val) } var o = { 'M+': date.getMonth() + 1, // 月份 'd+': date.getDate(), // 日 'h+': date.getHours(), // 小时 'm+': date.getMinutes(), // 分 's+': date.getSeconds(), // 秒 'q+': Math.floor((date.getMonth() + 3) / 3), // 季度 S: date.getMilliseconds() // 毫秒 } if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) } for (var k in o) { if (new RegExp('(' + k + ')').test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : (('00' + o[k]).substr(('' + o[k]).length))) } } return fmt } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-12-16 10:29:36 "},"js/regex-assertions.html":{"url":"js/regex-assertions.html","title":"正则表达式断言","keywords":"","body":"正则表达式之断言Assertion 零宽正向先行断言 表达式：x(?=y) 含义：仅匹配被y跟随的x Demo：匹配后缀名为jpg的文件名 `demo1.mpg demo2.png demo3.txt demo4.jpg demo5.gif demo6.js demo7.jpg`.match(/\\w+(?=\\.jpg)/g) 零宽度负向先行断言 表达式：x(?!y) 含义：仅匹配不被y跟随的x Demo：匹配后缀名不为jpg的文件名 `demo1.mpg demo2.png demo3.txt demo4.jpg demo5.gif demo6.js demo7.jpg`.split(' ').filter(file => /\\w+\\.(?!jpg)/.test(file)) 零宽度正向回顾断言 表达式：(? 含义：x只有在y后面才匹配 Demo：匹配苹果手机的型号 ['Apple 11', 'Mi 12', 'Huawei Nova', 'Apple 12 Pro', 'Vivo X11'].filter(item => /(? 零宽度负向回顾断言 表达式：(? 含义：x只有不在y后面才匹配 说明：JavaScript中不支持！ Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-04-22 15:58:28 "},"js/debounce-throttle.html":{"url":"js/debounce-throttle.html","title":"debounce和throttle","keywords":"","body":"debounce vs throttle 区别 debounce throttle 定义 防抖 节流/限频 含义 一个连续操作中的处理，只触发一次，从而实现防抖动。 一个连续操作中的处理，按照阀值时间间隔进行触发，从而实现节流。 使用场景 第一次触发后，进行倒计wait毫秒，如果倒计时过程中有其他触发，则重置倒计时；否则执行。用它来丢弃一些重复的密集操作，直到流量减慢。 第一次触发后先执行fn（lodash可以通过{leading: false}来取消），然后wait ms后再次执行，在单位wait毫秒内的所有重复触发都被抛弃。即如果有连续不断的触发，每wait ms执行fn一次，用在每隔一定间隔执行回调的场景。 Demo 网上介绍这2个概念的文章数不胜数，在此也不做多详述。我们来看实例，来加深理解。 debounce 功能 此demo模拟输入框搜索功能，右侧表格显示搜索的结果。 操作1 上面输入框不带debounce功能，我们快速输入\"arg\"。 下面黑色日志框记录了每次输入完后，调用接口的情况。即调用了3次查询接口。 下面输入框带debounce功能，我们同样快速输入\"arg\"。 黑色日志框只打出了1条log，即调用了1次查询接口。 操作2 滚动条滚动，发现header会固定在顶部（虽然有些延迟）。 总结1 代码中debounce的延迟时间设置为400，即400ms，0.4s。 我们的思想是待用户输入完后，或者是输入完一段后，我们才开始查询，而不是每输入完一个字符就开始查询。 这0.4s就是我们等待的时间，即当用户输入完后0.4内没有输入了，我们就认为用户结束输入，查询开始；反之，则在下个输入完后继续等0.4s（0.4s也是经验值，可以修改为你认为合适的阈值）。 总结2 吸顶功能，也是用debounce实现的。 window.scroll事件，会在短时间内出发多次。如果需要修改layout布局的话，就会非常影响性能和体验。使用防抖后，能够大大节省开销。 onscroll才是防抖动的经典场景，在短时间内出发多次。 throttle 功能 模拟了按钮点击事件。 操作 连续点击左侧按钮（Submit Form）3次。 底部打出3条记录。 连续点击中间按钮（Submit Form With throttle）3次（等待大约5s）。 底部会打出2条记录。第一条马上出现，第二条过了4s后出现。 连续点击右侧按钮（Submit Form With debounce）3次 底部打出1条记录，且是在停止点击后约4s。 结论 左侧按钮没有做节流，点击1次打出1条记录。这个不用解释。 中间按钮为什么出现这种现象，第一条和第二条间隔4s（代码中阈值设置为400）？ 回看顶部关于throttle节流使用场景的介绍。流程是： (1) 首先执行fn。 (2) 然后等待4s。 (3) 如果等待期间仍有触发，则在等待结束后再执行1次fn。 流程图如下： ​ 假如我们一直连续不断的快速点击中间节流按钮，throttle的效果就是：第一次立马执行，后面平均每4s执行1次。 右侧防抖按钮，只在停止后才触发。其流程： 第一次点击时，进行4s等待。 第二次点击时，重置前面的等待，重新开始第二次4s等待。 第三次点击，同样重新开始第三次4s等待。 4s后，执行fn。 请看其流程图： Code 通过2个实例，我们对debounce和throttle有了更深的认识。再来看看其代码，在上面的例子中我们用的是lodash中的方法，那么我们就分析一下它们的实现。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-06-22 10:06:58 "},"less-sass/":{"url":"less-sass/","title":"CSS & SASS & LESS记录","keywords":"","body":"SASS & LESS记录 背景 SASS和LESS均是CSS样式处理，本篇记录项目中的常见问题和用法。 本人在H3C项目中使用的是LESS，在目前Zoom使用的SASS。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-08 17:26:36 "},"less-sass/variable-trans.html":{"url":"less-sass/variable-trans.html","title":"SCSS变量转义","keywords":"","body":"变量转义 在LESS和SASS中有时需要对变量进行转义。 SASS 比如，在SASS中如用到calc计算属性时： $container-width: 200px; width: calc(100% - $container-width); 上述代码运行结果不正确，发现container-width并没有转为200px，而是直接显示了。 这时就需要转义，正确代码如下： $container-width: 200px; width: calc(100% - #{$container-width}); 在变量外包上#{}，即可实现变量转义。 LESS @count-per-row: 5; ul { & > li { &:not(:nth-child(@{count-per-row}n)) { margin-right: 10px; } } } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-10 15:01:05 "},"less-sass/css-flex.html":{"url":"less-sass/css-flex.html","title":"display: flex","keywords":"","body":"CSS flex flex是css3中好用的弹性布局。 flex布局中，至少包含2级，即Container和Item。 Container属性 flex-direction row 主轴为水平方向，起点在左端。 row-reverse 主轴为水平方向，起点在右端。 column 主轴为垂直方向，起点在上沿。 column-reverse 主轴为垂直方向，起点在下沿。 flex-wrap nowrap 不换行。 wrap 换行，在第一行的上方。 wrap-reverse 换行，在第一行的下方。 justify-content flex-start 左对齐。 flex-end 右对齐。 center 居中。 space-between 两端对齐，项目之间的间隔都相等。。 space-around 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items flex-start 交叉轴的起点对齐。 flex-end 交叉轴的终点对齐。 center 交叉轴的中点对齐。 baseline 项目的第一行文字的基线对齐。 stretch 如果项目为设置高度或者为auto，将占满整个容器的高度。 align-content flex-start 交叉轴的起点对齐。 flex-end 交叉轴的终点对齐。 center 交叉轴的中点对齐。 stretch 与交叉轴两端对齐，轴线之间的间隔平均分布。 space-between 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 space-around 轴线占满整个交叉轴。 Item属性 order 定义item的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 定义item的放大比例，默认为0，即如果存在剩余空间，也不放大。不为0，表示根据order值平分剩余空间。 flex-shrink 定义item的缩小比例，默认为1，即如果空间不足，该项目将缩小。 align-self 允许单个item有与其他项目不一样的对齐方式，可以覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-11 13:19:14 "},"less-sass/css-grid.html":{"url":"less-sass/css-grid.html","title":"display: grid","keywords":"","body":"CSS grid grid布局是css3中好用的网格布局。 grid布局中，至少包含2级，即Container和Item。 Demo 设置一个3x2的布局 html: item1 item2 item3 item4 item5 item6 css: #container { display: grid; grid-template-columns: 100px 200px 300px; grid-template-rows: 80px 200px; } 使用Repeat定义 如需重复定义多行/列，可以用repeat方法： #container { display: grid; grid-template-columns: repeat(3, 100px) 200px; grid-template-rows: repeat(2, 200px); } 使用fr等分 如需等分，可以用fr，即fraction. #container { display: grid; grid-template-columns: repeat(3, 1fr) 2fr 80px; grid-template-rows: repeat(2, 1fr); } 定义间距 #container_common_gap { display: grid; grid-template-columns: 100px 200px 300px; grid-template-rows: 80px 200px; row-gap: 10px; column-gap: 20px; } auto-fill自动填充 配合repeat，当item数量不确定，但是尺寸确定的话，可以使用auto-fill。 #container_autofill { display: grid; width: 320px; height: 320px; grid-template-columns: repeat(auto-fill, 100px); grid-template-rows: repeat(auto-fill, 50px); border: 1px solid #ccc; } 定义区域 Container父容器使用grid-template-areas来定义区域，子容器使用grid-area来定义自己的area name。 DOM Header Side Main Footer CSS #container_area { display: grid; grid-template-columns: 100px 500px; grid-template-rows: 80px 400px 50px; grid-template-areas: 'header header header' 'side main main' 'side main main' 'footer footer footer'; gap: 1rem; } #container_area > div { padding: 20px; } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2022-11-08 17:49:48 "},"less-sass/css-center.html":{"url":"less-sass/css-center.html","title":"display center","keywords":"","body":"CSS实现居中 如何使用css实现水平竖直居住，共三种方法： flex 设置父容器display为flex，然后align-items和justify-content为center来实现。 grid 设置父容器display为grid，然后align-items和justify-items为center来实现。 transform 设置父容器position: relative，自身position:absolute，然后top和left各自为50%相对值。最后通过transform偏移自身的50%进行校准。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-05-11 14:43:54 "},"less-sass/param-ergodic.html":{"url":"less-sass/param-ergodic.html","title":"遍历赋值","keywords":"","body":"循环遍历赋值 SCSS $color: ( primary: $color-primay, light-primary: $color-light-primay, success: $color-success, info: $color-info, warning: $color-warning, error: $color-error, text-title: $color-text-title, text-content: $color-text-content, text-subColor: $color-text-subColor, text-disabled: $color-text-disabled, border: $color-border, divider: $color-divider, background: $color-background ); html { @each $key, $val in $color { --color-#{$key}: #{$val}; } } LESS @color: { primary: #2d8cf0; title: #17233d; content: #515a6e; sub-color: #808695; disabled: #c5c8ce; border: #dcdee2; divider: #e8eaec; background: #f8f8f9; warning: #ff9900; }; html { each(@color, { --color-@{key}: @value; }); } Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-08-23 09:32:05 "},"NodeJS/":{"url":"NodeJS/","title":"NodeJS","keywords":"","body":"NodeJS记录 背景 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-29 15:22:49 "},"NodeJS/express-vue-picture-cropper.html":{"url":"NodeJS/express-vue-picture-cropper.html","title":"Vue-Picture-Cropper图片裁切上传","keywords":"","body":"vue-picture-cropper插件的使用 背景 前端项目使用vue3.0，需要有图片裁切的功能，如下： 页面中的表单除了裁剪后的图片外，还包含其它字段，如name和type。接下来会介绍如何使用vue-picture-cropper+Express来处理混合表单数据，实现图片的裁切加保存。 使用的组件 vue-picture-cropper 基于 cropper.js ，支持 Vue 3.0 的图片裁切工具组件（目前仅支持 Vue 3.x ）。 multer node.js 中间件，用于处理 multipart/form-data 类型的表单数据，它主要用于上传文件。它是写在 busboy 之上非常高效。 使用 前端页面使用 不做多述，参考《vue-picture-cropper github》 在提交表单的时候，使用Axiox需要注意以下2点： 表单数据 因为是混合表单数据，所以不能和简单的表单一样放在对象中。应统一放在FormData对象里： let formData = new FormData() formData.append('title', this.form.title) formData.append('type', this.form.type) formData.append('imgFieldName', this.$refs.cropper.getFile()) post请求头设置 须设置请求头中的Content-Type: Axios.post('/api/form', formData, {headers: { \"Content-Type\": \"multipart/form-data\" }}).then(res => { resolve(res.data) }) Express处理表单请求 const app = express() const path = require('path') const multer = require('multer') const upload = multer({ storage: multer.diskStorage({ destination (req, file, cb) { cb(null, path.join(__dirname, '../../../static/demo')) }, filename (req, file, cb) { const fileName = 'file_name_prefix' + ' - ' + file.originalname cb(null, fileName) } }) }) app.post('/api/form', upload.single('imgFieldName'),async function (req, res) { let img = '' if (req && req.file) { const {filename} = req.file } // TODO hadle with filename }) multer初始化destination是设置文件存储的路径,filename是设置文件名。 参考资料 《vue-picture-cropper github》 《multer github》 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-11-29 16:13:02 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 主要记录一些无分类的文章。 Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-09 15:00:39 "},"other/A11Y/":{"url":"other/A11Y/","title":"Accessbility","keywords":"","body":"Accessbility 概念 Accessibility，通常缩写为 A11Y ，这缩写取的是首字母 + 中间字母长度 + 结尾字母，译为 “可访问性”。这是一种让尽可能多的人访问我们所开发的网站的技术概念，通过这个概念，让互联网访问公平变得可能。 在国内A11Y在前端领域极易被忽略，也是一块技术冷门。在面试中极少会被问到，而在国外特别是受众比较广泛的前端应用，A11Y必不可少。虽然它不直接影响页面功能，但是没有它会极大影响有障碍的用户来访问我们的页面。 本篇记录本人在项目中从零开始，学习和应用A11Y的领悟，亦可作为新手学习入门的教程。 参考资料 不能永远忽略的 Accessibility (上) 不能永远忽略的 Accessibility (下) Web开发中最该知道却从不重视的 —— Accessibility Arial - Forms - Basic form hints Arial - Forms - Alerts The problem Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 17:59:13 "},"other/A11Y/landmarks.html":{"url":"other/A11Y/landmarks.html","title":"Landmarks","keywords":"","body":"LandMarks 前端开发人员写html时，很容易滥用标签，然而除了还有很多其它好用的标签。 下图是一个非常常见的页面结构： 以Header为例，我们写html时通常会怎么写？相信大部分人都会习惯性地这么编码： 假如我们使用了更合适的标签的话，代码变得更语义化，生动了。 什么是LandMark Landmark英文翻译是路标、地标。在html中，我们可以理解为语义化的标签，即见名知意的标签。 为什么推荐用 无论使用和，都可以实现我们的页面效果。但是这里讨论的是Accessbility，即让有某些障碍的用户能够更加方便地访问我们的页面。接下来，告诉你为什么要用。 使用第三方工具NVDA（有视觉障碍的用户，会使用类似工具软件，通过读屏的方式来浏览我们的页面，即screen reader users）。通过inseet+F7可以调出下面对话框。在Landmarks中，可见当前页面的结构： 如果只使用标签的话，这里完全看不出页面的结构，视障用户也很难定位到header或者footer元素。所以改掉原来的坏习惯，推荐用如下标签：,,,等。 假如因为某些原因不能使用这些标签的话，你可以增加WAI-ARIA的role属性来实现同样的目的。 Bad Good Awesome 常见的role banner 通常指页面的头部，即。 complementary 译为“补充的”，即页面的补充信息。如下图，页面的相关参考文档用了标签，这样landmarks工具就能抓取到该区域。同时增加了aria-labelledby指定了标签的id，从而进一步抓取到Related Documents文本。这样，极大地方便了视障用户获取该区域的信息。 标签默认的role为complementary。假如其他标签需要实现该role的话，可以： Title for complementary area contentinfo 一般为底部的用于展示页面基本信息的元素，通常称为。 form 顾名思义，即页面中的表单。如果用的是标签，那么不需要指定role；否则，则需要增加： Register Form 除此之外，还有几点需要注意： 如果页面包含多个form，那么如何区分？ 建议为每个form设置不同的aria-labelledby，这样读屏软件可以区分不同的form。 假如表单是完成搜索功能，那么建议role=\"search\"。 表单中的输入控件，最好也设置单独的role 如：button，input，select，textarea等。 main 每个页面至少有一个main。作用是展示页面的主要内容。 main应当在最外层。 假如有多个main，可以用aria-labelledby区分。 navigation 用于页面导航。 region 便于用户灵活定义功能区域，默认标签为。 title for main content area title for region area 1 title for region area 2 上面的例子，通过landmarks抓取到的结构： 还有另外3种写法，均可实现相同的效果，供参考： 使用标签 title for region area 1 使用aria-label title for region area 1 使用title title for region area 1 search 搜索功能的区域，使用role=\"search\"。 总结 区分role和tag的关系： Landmarks Role HTML Tag banner complementary form main navigation region search none 如果使用了右侧的默认标签，则不需要额外写role。否则，需要手动加上role。 banner，main，complementary和contentinfo这4个landmarks必须在最外层。 假如页面包含多个role，需要用label或者aria-labelledby或者title加以区分。 参考资料 ARIA Landmarks A11Y-101 - Landmarks Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-15 17:55:06 "},"webpack/async-in-vue-cli3.html":{"url":"webpack/async-in-vue-cli3.html","title":"vue.config.js中chainWebpack支持异步数据","keywords":"","body":"vue.config.js中chainWebpack支持异步数据 前言 项目背景 项目使用vue-cli4搭建的，如需修改Webpack的配置，需要修改vue.config.js。 项目中，在chainWebpack中调用了html-webpack-plugin生成dev.html文件。 html-webpack-plugin的配置templateParameters支持模板参数注入，支持对象和方法。本文就是基于这个配置做文章。如何配置可参考：templateParameters demo 在html页面接收foo参数，即可获得bar值： 需求 需要在dev.html注入一些数据，而这些数据是异步获取的（调用接口或者其他方式）。我这里是需要通过Node.js的child_process执行git命令，获取分支信息。 尝试 templateParameters支持function。可以尝试传入async方法，通过await获取到数据后，再返回。 遇到问题 chainWebpack和templateParameters均不支持异步。 chainWebpack改为异步后，打包报错。 templateParameters改为异步后，虽不影响打包，但是变量不生效。 苦于vue-cli-service和html-webpack-plugin均不支持异步，只能另想办法。 解决 查阅资料 先通过百度，国内貌似没有类似的记录文章。然后Google，果然找到了类似需求： Vue config async support 有人提出了类似的issue，虽然作者没有直接解决，但是也给出了一个work around： 改代码 这个方法的思路，实际上将npm run serve包了一层wrap，在外层拿到数据后，再通过代码调用npm run serve开始打包。接下来我们来完成这个wrap。 首先新建一个文件serve.prehandle.js，用于wrap。先获取异步数据，待拿到之后再开始打包： const getGitDevInfo = require('./src/pages/demo/webpack-plugin/git-info') const isDevEnv = process.env.NODE_ENV !== 'production' module.exports = (api, options) => { api.registerCommand('serve:prehandle', async (args) => { if (isDevEnv) { const def = await getGitDevInfo() process.asyncParamter = def } await api.service.run('serve', args) }) } module.exports.defaultModes = { 'serve:prehandle': 'development' } 然后修改package.json 修改serve命令 { \"scripts\": { \"serve\": \"vue-cli-service serve:prehandle\" } } 增加vuePlugins，对应上面的serve.prehandle命令，为这条命令指定处理文件 { \"vuePlugins\": { \"service\": [\"serve.prehandle.js\"] } } 修改vue.config.js去接收数据。这里我存在process全局变量中： config.plugin('html').use(HtmlWebpackPlugin, [{ filename: 'dev.html', template: 'src/pages/demo/index.html', templateParameters: { config: `window.devGitInfo=${JSON.stringify(process.asyncParamter || {})}` }, chunks: ['chunk-vendors', 'chunk-common', 'dev'], }]) 接下来，执行后可生效！ npm run serve 相关知识点 vue-cli Service Plugin vue-cli支持导入自定义的Service Plugin，具体参考下面文档： Project local plugin Add a new cli-service command Copyright © shiwang.wang 2021 all right reserved，powered by Gitbook该文件修订时间： 2021-03-18 10:04:33 "}}